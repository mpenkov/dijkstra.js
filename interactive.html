<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
  .node {
    stroke: black;
    stroke-width: 2px;
    fill: white;
  }
  .source { fill: red; }
  .destination { fill: blue }
  .current { fill: green; }
  .neighbor { fill: purple; }
  .intermediate { fill: orange; }

  .link-line {
    stroke: black;
    stroke-opacity: .6;
  }
  .link-text {
    stroke: black;
    stroke-opacity: 1.0;
  }
  .active { stroke: red; }
  .intermediate { fill: orange; stroke: orange; }
  </style>
</head>
  <body>
  <button onclick="step()">Click me</button>
  <script src="http://d3js.org/d3.v3.min.js"></script>
  <script src="min-heap.js"></script>
  <script src="dijkstra-interactive.js"></script>
  <script>
    function createGraph() {
      //
      // Return the graph at http://en.wikipedia.org/wiki/File:Dijkstra_Animation.gif
      // as a adjacency matrix.
      //
      var g = [];
      for (var i = 0; i < 6; ++i) {
          g[i] = [];
          g[i][i] = 0;
      }
      g[0][1] = 7;
      g[0][2] = 9;
      g[0][3] = Number.POSITIVE_INFINITY;
      g[0][4] = Number.POSITIVE_INFINITY;
      g[0][5] = 14;

      g[1][2] = 10;
      g[1][3] = 15;
      g[1][4] = Number.POSITIVE_INFINITY;
      g[1][5] = Number.POSITIVE_INFINITY;

      g[2][3] = 11;
      g[2][4] = Number.POSITIVE_INFINITY;
      g[2][5] = 2;

      g[3][4] = 6;
      g[3][5] = Number.POSITIVE_INFINITY;

      g[4][5] = 9;

      for (var i = 0; i < 6; ++i) {
          for (var j = 0; j < i; ++j) {
              g[i][j] = g[j][i];
          }
      }
      return g;
    }

    var srcNode = 0;
    var dstNode = 4;

    var graph = createGraph();
    dijkstra = new Dijkstra(graph, srcNode, dstNode);

    var width = 640,
      height = 480;

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);

    function step() {
      var result = dijkstra.step();
      if (result) {
        var shortest = dijkstra.shortestPath();
        console.debug(shortest.distance);
        svg.selectAll(".node").attr("class", "node");
        svg.selectAll(".node")
          .filter(function(d) {return shortest.nodes.indexOf(d.name) != -1;})
          .attr("class", "node intermediate");
        svg.selectAll(".node")
          .filter(function(d) {return d.name === dijkstra.srcNode;})
          .attr("class", "node source");
        svg.selectAll(".node")
          .filter(function(d) {return d.name === dijkstra.dstNode;})
          .attr("class", "node destination");

        var inter = function(d) {
          var src = d.source.index;
          var dst = d.target.index;
          for (var i = 0; i < shortest.edges.length; ++i) {
            var edge = shortest.edges[i];
            if ((edge.src === src && edge.dst === dst) || (edge.dst === src && edge.src === dst)) {
              return true;
            }
          }
          return false;
        };

        svg.selectAll(".link-text").attr("class", "link-text");
        svg.selectAll(".link-text")
          .filter(inter)
          .attr("class", "link-text active");
        svg.selectAll(".link-line").attr("class", "link-line");
        svg.selectAll(".link-line")
          .filter(inter)
          .attr("class", "link-line active");
        return;
      }

      var node = svg.selectAll(".node");
      node.attr("class", "node");
      node.filter(function(d) { return d.name === dijkstra.u ; })
        .attr("class", "node current");
      node.filter(function(d) { return d.name === dijkstra.v ; })
        .attr("class", "node neighbor");

      var currentFilter = function(d) { 
        var src = d.source.index;
        var dst = d.target.index;
        return (src === dijkstra.u && dst === dijkstra.v) ||
               (dst === dijkstra.u && src === dijkstra.v);
      };

      var linkText = svg.selectAll(".link-text");
      linkText.attr("class", "link-text");
      linkText.filter(currentFilter).attr("class", "link-text active");

      var linkLine = svg.selectAll(".link-line");
      linkLine.attr("class", "link-line");
      linkLine.filter(currentFilter).attr("class", "link-line active");
    }

    function graph2json(g) {
      // Return a graph in JSON notation as shown in http://bl.ocks.org/mbostock/4062045
      var result = {nodes: [], links: []}
      for (var i = 0; i < g.length; ++i) {
        var node = {"name": i};
        result.nodes.push(node);
        for (var j = i+1; j < g.length; ++j) {
          if (g[i][j] != Number.POSITIVE_INFINITY) {
            var edge = {"source": i, "target": j, "value": g[i][j]};
            result.links.push(edge);
          }
        }
      }
      return result;
    }

    function drawGraph(graph) {
      graph = graph2json(graph);
      var force = d3.layout.force()
          .charge(-1000)
          .linkDistance(200)
          .size([width, height])
          .nodes(graph.nodes)
          .links(graph.links);

      var link = svg.selectAll(".link-line")
          .data(graph.links)
          .enter();
      var linkLines = link.append("line")
          .attr("class", "link-line")
          .attr("source", function(d) { return d.source; })
          .attr("target", function(d) { return d.target; });
      var linkText = link.append("text")
          .attr("class", "link-text")
          .attr("text-anchor", "middle")
          .attr("source", function(d) { return d.source; })
          .attr("target", function(d) { return d.target; })
          .text(function(d) {
            return d.value;
          });

      var node = svg.selectAll(".node")
          .data(graph.nodes)
          .enter()
          // Add one g element for each data node here.
          .append("g");

      // Add a circle element to the previously added g element.
      node
          .append("circle")
          .attr("class", function(d) {
              cls = "node";
              if (d.name === srcNode) cls += " source";
              else if (d.name === dstNode) cls += " destination";
              return cls;
          })
          .attr("r", 20);
      // Add a text element to the previously added g element.
      node
          .append("text")
          .attr("text-anchor", "middle")
          .text(function(d) {
            return d.name;
          });
      node.call(force.drag);

      force.on("tick", function() {
        linkLines.attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });
        linkText.attr("x", function(d) { return (d.source.x+d.target.x)/2; });
        linkText.attr("y", function(d) { return (d.source.y+d.target.y)/2; });
        node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
      });

      force.start();
    }

    drawGraph(graph);
  </script>
</body>
</html>
